## [item 10] equals 는 일반 규약을 지켜 재정의하라.

- 모든 클래스는 Object 클래스를 상속 받고 Object 클래스의 final 이 아닌 메서드를 오버라이딩할 수 있다. 그 중 equals 메서드애 대해 언제 어떻게 재정의해야 하는지 알아보자.

### equals 메서드를 재정의 하지 않아도 되는 상황

1. 각 인스턴스가 본질적으로 고유할 때
   - 해당 인스턴스가 어떠한 값을 표현하기 위한 목적이 아니라 동작하는 인스턴스를 표현하는 클래스에 해당한다.
2. 인스턴스의 논리적 동치성을 검사할 필요가 없을 때
3. 상위 클래스에서 재정의한 equals 가 정의되어 있을 때
   - List, Set, Map 의 상위 클래스에 equals 메서드가 구현되어 있기 때문에 직접 구현할 필요가 없다.
4. 클래스가 private 이거나 package-private 이고 equals 메서드를 호출할 일이 없을 때

*즉 equals 메서드를 재정의해야 할 때는 객체식별성 (두 객체가 물리적으로 같은가)이 아니라 논리적 동치성을 확인해야 하는데 상위 클래스의
equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때다.*

### equals 메서드 를 재정의 할 경우 따라야 할 규약

#### 1. 반사성
- ```A.equals(A) == true```
- 본인이 본인과 비교를 했을 떄 같다고 나와야한다.

#### 2. 대칭성
- ```A.equals(B) == B.equals(A)```
- A 객체에서 B 객체를 비교한 결과와 B 객체에서 A 객체를 비교한 결과가 같아야한다.
- 대칭성을 위배하지 않으려면 본인의 타입에 대해서만 비교하는 것이 좋다.


#### 3. 추이성
- ```A.equals(B) && B.equals(C) => A.equals(C)```
- A 객체와 B 객체가 같고 B 객체가 C 객체와 같으면 A 객체는 C 객체와 같다.
- 이는 **한 클래스를 상속받아 필드를 추가 후 equals 메서드를 재정의하면서 발생하는 경우가 많다.**
- 상속을 받아 필드를 추가하고 equals 를 사용하고 싶은 경우에는 상속대신 **컴포지션**을 사용해 필드를 추가한다.

#### 4. 일관성
- ```A.equals(B) == A.equals(B)```
- A.equals(B) 를 호출했으면 결과는 반복해서 호출했을 때 결과가 같아야한다.

#### 5. null 아님
- ```A.equals(null) == false```
- 어떤 인스턴스가 equals 메서드에 null 을 넘겼을 때 false 가 나와야한다.

### 양질의 equals 메서드 구현 방법

1. == 연산자를 사용해 입력이 자기 자신의 참조인지 확인 (성능 최적화용)
2. instanceof 연산자로 입력이 올바른 타입인지 확인
3. 입력을 올바른 타입으로 형변환
4. 입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 하나씩 검사